<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrankRooms Virtual Tour</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 200px;
        }
        .control-row {
            display: flex;
            gap: 10px;
        }
        .btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            white-space: nowrap;
        }
        .btn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
        }
        .btn-small {
            padding: 8px 12px;
            font-size: 12px;
        }
        select {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            width: 100%;
        }
        select:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.6);
        }
        select option {
            background: rgba(0, 0, 0, 0.95);
            color: white;
        }
        #share-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            max-width: 500px;
            z-index: 200;
        }
        #share-panel input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 14px;
        }
        #share-panel button {
            margin: 5px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            z-index: 100;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="loading">Loading CrankRooms...</div>
    
    <div id="controls">
        <select id="bgColor">
            <option value="0x87ceeb">Sky Blue</option>
            <option value="0x1a1a1a">Dark Gray</option>
            <option value="0x000000">Black</option>
            <option value="0xffffff">White</option>
            <option value="0x2c3e50">Midnight Blue</option>
            <option value="0x34495e">Slate Gray</option>
            <option value="0xecf0f1">Light Gray</option>
            <option value="0x95a5a6">Silver</option>
        </select>
        
        <div class="control-row">
            <button class="btn btn-small" id="toggleGrid">Hide Grid</button>
            <button class="btn btn-small" id="resetCamera">Reset View</button>
        </div>
        
        <div class="control-row">
            <button class="btn btn-small" id="screenshot">Screenshot</button>
            <button class="btn btn-small" id="fullscreen">Fullscreen</button>
        </div>
        
        <button class="btn btn-small" id="shareLink">Share Link</button>
    </div>
    
    <div id="share-panel" class="hidden">
        <h3>Share This View</h3>
        <p>Copy this link to share your current camera position:</p>
        <input type="text" id="share-url" readonly>
        <div>
            <button class="btn" id="copyLink">Copy Link</button>
            <button class="btn" id="closeShare">Close</button>
        </div>
    </div>
    
    <div id="info">
        <h3>Controls</h3>
        <p><strong>Left Mouse:</strong> Rotate view<br>
        <strong>Right Mouse:</strong> Pan<br>
        <strong>Scroll:</strong> Zoom in/out</p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        
        // Camera setup (isometric-style view)
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(10, 10, 10);
        
        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Orbit Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 50;
        controls.maxPolarAngle = Math.PI / 2;
        
        // Lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 15, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-5, 10, -5);
        scene.add(fillLight);
        
        // Grid helper for reference
        const gridHelper = new THREE.GridHelper(20, 20, 0x888888, 0x444444);
        scene.add(gridHelper);
        
        // Store initial camera position
        let initialCameraPosition = new THREE.Vector3();
        let initialCameraTarget = new THREE.Vector3();
        
        // Toggle grid button
        let gridVisible = true;
        document.getElementById('toggleGrid').addEventListener('click', () => {
            gridVisible = !gridVisible;
            gridHelper.visible = gridVisible;
            document.getElementById('toggleGrid').textContent = gridVisible ? 'Hide Grid' : 'Show Grid';
        });
        
        // Background color dropdown
        document.getElementById('bgColor').addEventListener('change', (e) => {
            const color = parseInt(e.target.value);
            scene.background = new THREE.Color(color);
        });
        
        // Reset camera
        document.getElementById('resetCamera').addEventListener('click', () => {
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialCameraTarget);
            controls.update();
        });
        
        // Screenshot
        document.getElementById('screenshot').addEventListener('click', () => {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'crankrooms-screenshot.png';
            link.href = dataURL;
            link.click();
        });
        
        // Fullscreen
        document.getElementById('fullscreen').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.getElementById('fullscreen').textContent = 'Exit FS';
            } else {
                document.exitFullscreen();
                document.getElementById('fullscreen').textContent = 'Fullscreen';
            }
        });
        
        // Share link
        function generateShareURL() {
            const pos = camera.position;
            const target = controls.target;
            const params = new URLSearchParams({
                px: pos.x.toFixed(2),
                py: pos.y.toFixed(2),
                pz: pos.z.toFixed(2),
                tx: target.x.toFixed(2),
                ty: target.y.toFixed(2),
                tz: target.z.toFixed(2)
            });
            return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
        }
        
        function loadCameraFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('px')) {
                camera.position.set(
                    parseFloat(params.get('px')),
                    parseFloat(params.get('py')),
                    parseFloat(params.get('pz'))
                );
                controls.target.set(
                    parseFloat(params.get('tx')),
                    parseFloat(params.get('ty')),
                    parseFloat(params.get('tz'))
                );
                controls.update();
            }
        }
        
        document.getElementById('shareLink').addEventListener('click', () => {
            const url = generateShareURL();
            document.getElementById('share-url').value = url;
            document.getElementById('share-panel').classList.remove('hidden');
        });
        
        document.getElementById('copyLink').addEventListener('click', () => {
            const input = document.getElementById('share-url');
            input.select();
            document.execCommand('copy');
            document.getElementById('copyLink').textContent = 'Copied!';
            setTimeout(() => {
                document.getElementById('copyLink').textContent = 'Copy Link';
            }, 2000);
        });
        
        document.getElementById('closeShare').addEventListener('click', () => {
            document.getElementById('share-panel').classList.add('hidden');
        });
        
        // GLTF Loader
        const loader = new GLTFLoader();
        
        // Load CrankRooms model
        loader.load(
            'CrankRooms.gltf',
            function(gltf) {
                const model = gltf.scene;
                scene.add(model);
                
                // Enable shadows and fix transparency
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // Fix transparency for materials
                        if (child.material) {
                            // Force transparency if opacity is less than 1
                            if (child.material.opacity !== undefined && child.material.opacity < 1) {
                                child.material.transparent = true;
                                child.material.depthWrite = false;
                                child.material.side = THREE.DoubleSide;
                            }
                            
                            // Check if material name suggests glass
                            const matName = child.material.name ? child.material.name.toLowerCase() : '';
                            if (matName.includes('glass') || matName.includes('window') || matName.includes('transparent')) {
                                child.material.transparent = true;
                                if (child.material.opacity === undefined || child.material.opacity === 1) {
                                    child.material.opacity = 0.3;
                                }
                                child.material.depthWrite = false;
                                child.material.side = THREE.DoubleSide;
                            }
                            
                            // Log material info for debugging
                            if (child.material.opacity < 1 || matName.includes('glass')) {
                                console.log('Transparent material found:', {
                                    name: child.material.name,
                                    opacity: child.material.opacity,
                                    transparent: child.material.transparent
                                });
                            }
                        }
                    }
                });
                
                // Center the model and adjust camera
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                
                // Move model to origin
                model.position.sub(center);
                
                // Calculate ideal camera distance
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * 1.5;
                
                // Position camera at an isometric-like angle
                camera.position.set(cameraZ, cameraZ * 0.8, cameraZ);
                camera.lookAt(0, 0, 0);
                
                // Store initial position
                initialCameraPosition.copy(camera.position);
                initialCameraTarget.copy(new THREE.Vector3(0, 0, 0));
                
                // Update controls
                controls.target.set(0, 0, 0);
                controls.update();
                
                // Check URL parameters for camera position
                loadCameraFromURL();
                
                // Hide loading message
                document.getElementById('loading').classList.add('hidden');
                
                console.log('CrankRooms loaded successfully!');
                console.log('Model size:', size);
            },
            function(xhr) {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                document.getElementById('loading').textContent = `Loading CrankRooms... ${percent}%`;
            },
            function(error) {
                console.error('Error loading CrankRooms.gltf:', error);
                document.getElementById('loading').textContent = 'Error: Could not load CrankRooms.gltf';
                document.getElementById('loading').style.color = '#ff6b6b';
                
                // Show helpful error message
                setTimeout(() => {
                    document.getElementById('loading').innerHTML = `
                        <strong>Error loading model</strong><br><br>
                        Make sure:<br>
                        • CrankRooms.gltf is in the same folder<br>
                        • File name matches exactly (case-sensitive)<br>
                        • File isn't corrupted<br><br>
                        Check browser console (F12) for details
                    `;
                }, 1000);
            }
        );
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
